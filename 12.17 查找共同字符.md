### 题目：

1002\. 查找共用字符

给你一个字符串数组 words ，请你找出所有在 words 的每个字符串中都出现的共用字符（包括重复字符），并以数组形式返回。你可以按 任意顺序 返回答案。

&nbsp;

示例 1：

输入：words = \["bella","label","roller"]

输出：\["e","l","l"]



示例 2：

输入：words = \["cool","lock","cook"]

输出：\["c","o"]

&nbsp;



### 解法与代码：

首先这道题目由于是要统计共同出现的字符，如果重复，那么也需要重复输出。

暴力解法：对于第一个单词的每一个字符，都遍历剩下的所有单词，且需要想办法进行对应上的单词的删除和恢复，很麻烦，且时间复杂度是O(n\*m)，是指数级别的，很搞。

那么我们考虑使用哈希法，由于所有的单词全是小写字母，且给定的单词的长度最大就是100，那么我们可以直接使用数组，长度为100即可。

一个二维数组，每一行表示一个单词的字符统计频率，每一列表示一个单词，列数只需要26就行。

我们选取每一列的最小值，按照这个最小值进行对应单词的输出，string（1，j+'a'）

##### 代码：

##### vector<string> commonChars(vector<string>\& words) {

##### &nbsp;       int n = words.size();// 表示n个word

##### &nbsp;       vector<vector<int>> freq(n,vector<int>(26,0));// 每个字符最长就100

##### &nbsp;       for(int i=0;i<n;i++){

##### &nbsp;           for(auto ch:words\[i]){

##### &nbsp;               freq\[i]\[ch-'a']++;

##### &nbsp;           } 

##### &nbsp;       }

##### &nbsp;       // 统计完了所有单词中的字母出现的频率之后，我们按列遍历，选择每一列中最小的那个元素，如果找到0，那么可以直接停止了

##### &nbsp;       vector<string> result;

##### &nbsp;       for(int j=0;j<26;j++){

##### &nbsp;           int min = 105;

##### &nbsp;           for(int i=0;i<n;i++){

##### &nbsp;               if(freq\[i]\[j] < min) min = freq\[i]\[j];

##### &nbsp;           }

##### &nbsp;           while(min--){

##### &nbsp;               result.push\_back(string(1,j+'a'));// 这是string的构造方法。

##### &nbsp;           }

##### &nbsp;       }

##### &nbsp;       return result;

##### &nbsp;   }





