二分查找：
使用的前提1.有序2.没有重复元素。

细节注意点：维护的区间。主要有[] 和 [)两种
两者的区别：1.while结束的条件，前者while(left<=right)，后者while(left<right)
2.逻辑判断。前者left = mid + 1,right = mid - 1.后者right = mid;left = mid+1。当然这些赋值，都是在判断了nums[mid] < target 或者nums[mid] > target的时候进行的，如果nums[mid] == target，则直接找到，返回。

这里我们详细讲讲左闭右开的使用。左闭右开主要用于寻找边界，比如寻找第一个>=target的元素。此时[left,right)的right位置，就是一个安全的上界，i>=right的位置，nums[i] >= target。i<left的位置，
nums[i] < target。
由于分界点是可能等于n的，也就是超出index的范围，所以我们考虑使用左闭右开区间。
1.语义正确：关键的逻辑判断：nums[mid] >= target：此时我们要找的ans，一定在[L,mid)（ans可以等于mid，因为边界本来就是一个开区间的概念）, 一定不在[mid,R]里。这一点保证了语义的正确。
2.区间是严格减小的（防止死循环）：由于我们是right = mid 这样收缩右边界。在最小长度时[L,L+1]，一定需要能长度收缩至L==R才行。向下取整，mid = left，这样不管如何，if else判断完，
L==R。
如果采用向上取整，此时mid = right，如果出现nums[mid] >= target的情况，那么right = mid，此时区间没有减小，会出现死循环的情况！
通俗的说：向下取整满足了：mid用于小于R，这样我们可以放心的使用right = mid这样的收缩方式。

AI的解释：
语义正确：
mid 是一个“可能的答案”，所以 ans 必须落在 [L, mid]，这就要求 right = mid。

区间严格减少：
为了保证 right = mid 真的“收缩”，mid 必须严格小于 R，而这由“左闭右开 + 向下取整”共同保证。


移除元素：
	快慢指针。fast遍历整个数组，slow维护不等于val的元素。