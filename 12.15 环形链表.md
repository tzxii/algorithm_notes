# 题目：

142\. 环形链表 II

给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。



如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。



不允许修改 链表。



# 代码与解法：

说实话不会写。



实现的思路：快慢指针，fast每次走两步，slow每次走一步。

fast和slow一定会在环内相遇的。因为fast优先进入环。然后fast就在这个环里面循环，而且fast和slow有速度差，那么一定会在环里面相遇。



然后的问题就在于，二者相遇的点和环的入口，有什么关系，如何找到环的入口？这需要画一下图，列一个等式，我们有 x+2y+z = 2(x+y)

最后得到x = z。也就是只需要两个指针分别从head和从相遇点出发，其相遇的点，就是我们环的入口！



但是还是需要注意一点，就是我们的while循环的继续条件是fast!=NULL \&\& fast->next!=NULL



##### 代码：ListNode \*detectCycle(ListNode \*head) {

##### &nbsp;       ListNode\* fast = head;

##### &nbsp;       ListNode\* slow = head;

##### &nbsp;       while(fast!=NULL \&\& fast->next != NULL){

##### &nbsp;           slow = slow->next;

##### &nbsp;           fast = fast->next->next;

##### &nbsp;           if(slow==fast){

##### &nbsp;               ListNode\* start = head;

##### &nbsp;               while(start!=fast){

##### &nbsp;                   start = start->next;

##### &nbsp;                   fast = fast->next;

##### &nbsp;               }

##### &nbsp;               return start;

##### &nbsp;           }

##### &nbsp;       }

##### &nbsp;       return NULL;

##### &nbsp;   }



