题目：
1. 两数之和
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。
示例 1：
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

示例 2：
输入：nums = [3,2,4], target = 6
输出：[1,2]

示例 3：
输入：nums = [3,3], target = 6
输出：[0,1]

关键的思路和代码：

首先我们要求在小于O(n^2)的时间复杂度求解。暴力便利就是n方的复杂度。
1.于是我们考虑使用哈希法，哈希表存储已经便利过的元素（也就是出现在数组中的元素）。
2.使用map而不是set。因为题目最后要求返回的是元素的下标，而不仅仅是判断是否存在和为target的两个元素。
map和set的底层实现都是红黑树，当然这是有序的情况下，unordered_map的底层实现是哈希表。
set的核心功能就是只关注判断元素是否出现过，于是元素本身就是key，而map注重映射，key用来排序，value无所谓其值。我们关心下标，那么：
3.map中的key应该是元素的值，value是元素的下标，这样就能顺利地通过target-nums[i]判断元素是否出现过，然后获取其下标。



