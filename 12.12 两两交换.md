# 题目：

24\. 两两交换链表中的节点

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）



# 解法与代码：

##### 注意：

##### 1.dummyhead

##### 2.一次处理两个节点，但是涉及四个指针。

##### cur cur->next cur->next->next cur->next->next->next

##### 其中 cur 是待处理的节点的前一个。

##### 也就是我们是 cur A B C 这样，A B是待处理的节点，C可能为nullptr

##### 3.临时变量保存A：cur->next 和C：cur->next->next

##### 4.注意需要保持前驱节点。否则交换完了之后ABC变成BAC，前驱节点还是以为后继是A,这就不能保持完整的连贯和连通了，也就是交换完的节点不好再放回去了。

##### 5.其实就是两点：1.前驱保证链表顺序的结构 如果不保留 cur，交换后的链表无法重新连接到原链表，导致交换的第一个节点（B）无法被前面的节点指向，从而被孤立。2.保存节点防止丢失。因为更改cur->next的时候，cur->next被覆盖了。

/\*\*

 \* Definition for singly-linked list.

 \* struct ListNode {

 \*     int val;

 \*     ListNode \*next;

 \*     ListNode() : val(0), next(nullptr) {}

 \*     ListNode(int x) : val(x), next(nullptr) {}

 \*     ListNode(int x, ListNode \*next) : val(x), next(next) {}

 \* };

 \*/

class Solution {

public:

    ListNode\* swapPairs(ListNode\* head) {

        ListNode\* dummyhead = new ListNode(0);

        dummyhead->next = head;

        ListNode\* cur = dummyhead;

#####         **while(cur->next!=nullptr \&\& cur->next->next!=nullptr){**

##### **ListNode\* tmp = cur->next;**

##### **ListNode\* tmp2 = cur->next->next->next;**

##### 

##### **cur->next = cur->next->next;**

##### **cur->next->next = tmp;**

##### **cur->next->next->next = tmp2;**

##### 

##### **cur = cur->next->next;**

##### **}**

        return dummyhead->next;

    }

};

