# 题目：

面试题 02.07. 链表相交

给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。

# 代码、解法与思路：

**1.对于相交的理解要深刻：短的链表不可能和长的链表在长的链表开头进行相交，否则短的链表在相交的后面会短一截，不符合相交的情况。**

**2.所以offset = abs(lenA-lenB) 相交的点肯定至少是在长的链表的 head往后数offset之后（包含head）。**

“如果两个单链表相交，那么它们从“第一个相交节点”开始，到结尾这一整段是完全同一条链；因此只要让两个指针距离尾部的步数相同，同步前进，第一次相等的位置就是交点。”

class Solution {

public:

&nbsp;   ListNode \*getIntersectionNode(ListNode \*headA, ListNode \*headB) {

&nbsp;       // 由于我们不知道先遍历哪一个链表，害怕错过，所以我们先统计两者长度，先处理长的链表。

&nbsp;       // 原因：如果相交，那么一定是从相交的节点开始，后面全部一样。也就是说，短的链表不可能和长的链表在前面相交，不然会导致后面不能对齐。

&nbsp;       ListNode\* curA = headA;

&nbsp;       ListNode\* curB = headB;

&nbsp;       int lenA = 0,lenB = 0;

&nbsp;       while(curA != NULL){

&nbsp;           curA = curA->next;

&nbsp;           lenA ++;

&nbsp;       }

&nbsp;       while(curB != NULL){

&nbsp;           curB = curB->next;

&nbsp;           lenB ++;

&nbsp;       }

&nbsp;       curA = headA;

&nbsp;       curB = headB;

&nbsp;       int offset;

&nbsp;       if(lenA > lenB){

&nbsp;           offset = lenA - lenB;

&nbsp;           while(offset>0){

&nbsp;               curA = curA->next;

&nbsp;               offset--;

&nbsp;           }

&nbsp;       }

&nbsp;       else if(lenA < lenB){

&nbsp;           offset = lenB - lenA;

&nbsp;           while(offset > 0){

&nbsp;               curB = curB -> next;

&nbsp;               offset--;

&nbsp;           }

&nbsp;       }

&nbsp;       // 此时处理完之后，curA和curB为首的链表长度就相同了，我们可以开始遍历了

&nbsp;       while(curA != NULL){

&nbsp;           if(curA == curB){

&nbsp;               return curA;

&nbsp;           }

&nbsp;           else {

&nbsp;               curA = curA->next;

&nbsp;               curB = curB->next;

&nbsp;           }

&nbsp;       }

&nbsp;       return NULL;

&nbsp;   }

};



##### 当然，本题还有更简洁的更骚的写法：

谁先把自己的路跑完，就去补跑对方的。

ListNode\* pA = headA;

ListNode\* pB = headB;

while(pA!=pB){
	pA = pA? pA -> next : headB;

&nbsp;	pB = pB? pB -> next : headA;

}

return pA;

总之就是，走完自己的之后，就去走对方的，这样就能实现尾部对齐了。

