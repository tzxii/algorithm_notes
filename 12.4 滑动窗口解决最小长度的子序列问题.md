### **题目：**

给定一个含有 n 个正整数的数组和一个正整数 target 。



找出该数组中满足其总和大于等于 target 的长度最小的 子数组 \[numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。



示例 1：

输入：target = 7, nums = \[2,3,1,2,4,3]

输出：2

解释：子数组 \[4,3] 是该条件下的长度最小的子数组。



示例 2：

输入：target = 4, nums = \[1,4,4]

输出：1



示例 3：

输入：target = 11, nums = \[1,1,1,1,1,1,1,1]

输出：0

&nbsp;



# 滑动窗口（本质上是双指针）：

&nbsp;	由于我们追求O(n)的复杂度，那么就不能for循环遍历窗口起始位置了，我们遍历终点位置，然后遇到sum到达标准的时候，缩小窗口，具体则是在for循环里面写一个while（sum>=target），这样可以向后移动我们的起点位置。具体则是，先记录当前窗口长度，然后向后移动起点，并且减少相应的sum，然后进入下一轮while循环。注意，这里的起点位置，是不用在每一轮while里重置的，否则就仍然是O(n^2)了。不用重置的正确性在于，我们是确定终点位置的，那么起点位置肯定不用考虑再向前了，只用考虑向后就行。


