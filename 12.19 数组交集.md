# 题目：

349\. 两个数组的交集



给定两个数组 nums1 和 nums2 ，返回 它们的 交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。



示例 1：

输入：nums1 = \[1,2,2,1], nums2 = \[2,2]

输出：\[2]



示例 2：

输入：nums1 = \[4,9,5], nums2 = \[9,4,9,8,4]

输出：\[9,4]

解释：\[4,9] 也是可通过的



# 解法与代码：

这道题限制了数组的长度以及数字的范围（主要是要看数值范围是否给出，如果给出了数值范围，那么就用数组），那么可以直接数组解决：

这是我的代码：**vector<int> intersection(vector<int>\& nums1, vector<int>\& nums2) {**

        **vector<vector<int>> fre(2,vector<int>(1001,0));//统计出现次数**

        **for(int i=0;i<nums1.size();i++){**

            **fre\[0]\[nums1\[i]]++;**

        **}**

        **for(int i=0;i<nums2.size();i++){**

            **fre\[1]\[nums2\[i]]++;**

        **}**

        **vector<int> result;**

        **for(int i=0;i<1001;i++){**

            **if(fre\[0]\[i]>0 \&\& fre\[1]\[i]>0){**

                **result.push\_back(i);**

            **}**

        **}**

        **return result;**

    **}**

**这是代码随想录给出的代码：**

**vector<int> intersection(vector<int>\& nums1, vector<int>\& nums2) {**

        **unordered\_set<int> result\_set; // 存放结果，之所以用set是为了给结果集去重**

        **int hash\[1005] = {0}; // 默认数值为0**

        **for (int num : nums1) { // nums1中出现的字母在hash数组中做记录**

            **hash\[num] = 1;**

        **}**

        **for (int num : nums2) { // nums2中出现话，result记录**

            **if (hash\[num] == 1) {**

                **result\_set.insert(num);**

            **}**

        **}**

        **return vector<int>(result\_set.begin(), result\_set.end());**

    **}**

**如果说没有给出对应的数值范围呢？由于数值分散+不考虑重复+不知道数值范围，我们也可以使用unordered\_set。**

**代码如下：**

**vector<int> intersection(vector<int>\& nums1, vector<int>\& nums2) {**

        **unordered\_set<int> result\_set; // 存放结果，之所以用set是为了给结果集去重**

        **unordered\_set<int> nums\_set(nums1.begin(), nums1.end());**

        **for (int num : nums2) {**

            **// 发现nums2的元素 在nums\_set里又出现过**

            **if (nums\_set.find(num) != nums\_set.end()) {**

                **result\_set.insert(num);**

            **}**

        **}**

        **return vector<int>(result\_set.begin(), result\_set.end());**

    **}**



**问题来了：unordered\_set和set的区别。**

**set：底层红黑树，自动有序，Logn 的 查找插入删除。关注顺序，比如最大值最小值之类的。**

**unordered\_set：底层哈希表。只关注在不在。**



