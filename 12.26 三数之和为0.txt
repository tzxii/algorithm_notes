题目：
15. 三数之和
给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。
注意：答案中不可以包含重复的三元组。

示例 1：
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。

示例 2：
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。

示例 3：
输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。

解法与代码：
重点有两个：1.找到合适的组合，这个直接判断就行。且用set可以帮助寻找。2.去重。
我们这里值得注意，set可以解决一部分的去重问题，由于set的特性，其本身就是集合，元素是不重复的，也就是{1}的set再insert一个1，仍然还是{1}。
但是其实还有一些需要经验补救的方法，也就是不是算法本身结构性就能稳定解决的问题，这需要额外的一些if判断去解决，而第一次写一般注意不到，这就是这个方法的缺点：缺少安全感。

举例而言：当出现连续三个相同元素的时候，且k指向第三个的时候，我们已经能知道，由于我们已经排序+找的是三元组，那么有用的集合肯定在前面就已经被处理过了，再处理肯定就是重复了。但是这种情况比如-2 1 1 1才会 而-3 1 1 1 2 2就不需要这个判断，用set的
特性就能得到结果。但是我们写代码的时候，直觉上肯定思考的是第二种情况，而不是第一种。所以这个set方法值得商榷。


代码：
vector<vector<int>> threeSum(vector<int>& nums) {
        // 我们先写一个朴素的方法，（当然最朴素的应该是使用n立方复杂度的暴力解法，但是暴力法已经有这么高的复杂度的前提下，
        // 还需要进行事后的去重，这是我们不能接受的）
        // 于是我们想到在生成结果的时候去重，那么考虑去重这一行为 + 判断之前是否已经出现这一要求，我们选择unordered_set
        // 当然去重其实还是靠if判断进行逻辑上的去重的。在生成结果的时候以及选择候选元素的时候进行逻辑判断。
        sort(nums.begin(),nums.end());
        vector<vector<int>> result;
        for(int i=0;i<nums.size();i++){
            // i是第一个元素，如果其和nums[i-1]一致，那么其实就是上一轮的那个分支了。剪枝。
            if(i > 0 && nums[i] == nums[i-1]){
                continue;
            }
            // 每确定一个新的a（第一个位置的元素），都新建一个set
            unordered_set<int> set;
            // 此时如果 b 和 c 已经可能在之前的组合中出现过，那么需要避免。由于set可以保证
            for(int k = i+1;k<nums.size();k++){
                if(k > i+2 && nums[k] == nums[k-1] && nums[k-1] == nums[k-2]){
                    continue;
                    // 由于已经固定了a，且我们只选择三元组。那么如果看到三个相邻且相等的元素，且此时已经k是第三个了，
                    // 有意义的组合肯定前面的逻辑已经处理过了，那么此时可以跳过。
                }
                int target = 0 - (nums[i]+nums[k]);
                if(set.find(target) != set.end()){
                    result.push_back({nums[i],target,nums[k]});
                    set.erase(target);
                }
                else{
                    set.insert(nums[k]);
                }
            }
        }
        return result;
    }

更安全、现代的方法：双指针法。

仍然是控制a，遍历b、c，但是此时的b、c含义特别明确，且是在排序过后的情况下的双指针，情况很清晰明了。
思考：两数之和的问题，要求返回下标，还能否使用双指针？不能，因为双指针法需要排序。

vector<vector<int>> threeSum(vector<int>& nums) {
        // 出于对安全感的考虑，我们还是使用更加现代和优美的双指针写法吧.
        vector<vector<int>> result;
        sort(nums.begin(),nums.end());
        for(int i=0;i<nums.size()-2;i++){
            // 为了保证left的设置是合理的，我们还是使i只能到倒数第三个 ，即nums.size() - 3
            if(i > 0 && nums[i] == nums[i-1]){
                continue;// 去重
            }
            int left = i + 1;
            int right = nums.size() - 1;
            while(left < right){
                int tmp = nums[i] + nums[left] + nums[right];
                if(tmp < 0){
                    left ++;
                }
                else if(tmp > 0){
                    right--;
                }
                else{
                    result.push_back({nums[i],nums[left],nums[right]});
                    while(left < right && nums[left] == nums[left + 1]) left++;
                    while(left < right && nums[right] == nums[right - 1]) right--;
                    left++;
                    right--;
                }
            }
        }
        return result;
    }

